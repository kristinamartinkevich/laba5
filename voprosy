1,2. Что такое производный и базовый классы?В чем заключена основная задача наследования?

Наследование является одним из трех основополагающих принципов объектно-ориентированного программирования, поскольку оно допускает создание иерархических классификаций. Благодаря наследованию можно создать общий класс, в котором определяются характерные особенности, присущие множеству связанных элементов. От этого класса могут затем наследовать другие, более конкретные классы, добавляя в него свои индивидуальные особенности.

В языке C# класс, который наследуется, называется базовым, а класс, который наследует, — производным. Следовательно, производный класс представляет собой специализированный вариант базового класса. Он наследует все переменные, методы, свойства и индексаторы, определяемые в базовом классе, добавляя к ним свои собственные элементы.

Поддержка наследования в C# состоит в том, что в объявление одного класса разрешается вводить другой класс. Для этого при объявлении производного класса указывается базовый класс. При установке между классами отношения "является" строится зависимость между двумя или более типами классов. Базовая идея, лежащая в основе классического наследования, заключается в том, что новые классы могут создаваться с использованием существующих классов в качестве отправной точки:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    class ProfessorWeb
    {
        const string ADDR = "http:\\professorweb.ru";
        public string level, inLevel;
        public int numberSt;
        private string inf;

        public void InfoPW()
        {
            Console.WriteLine("Сайт: {0}\nРаздел: {1}\nПодраздел: {2}\nКол-во статей:{3}",ADDR,level,inLevel,numberSt);
        }
    }

    // Объявляем класс, унаследованный от класса ProfessorWeb
    class CSharp : ProfessorWeb
    {
        public string st;

        // Поля класса ProfessorWeb доступны через конструктор наследуемого класса
        public CSharp(string level, string inLevel, int numberSt, string st)
        {
            this.level = level;
            this.inLevel = inLevel;
            this.numberSt = numberSt;
            this.st = st;
        }

        public void StWrite()
        {
            Console.WriteLine("Статья: "+st);
        }
    }

    class Program
    {
        static void Main()
        {
            CSharp obj = new CSharp(level: "C#", inLevel: "Перегрузка", numberSt: 7, st: "Перегрузка методов");
            obj.InfoPW();
            obj.StWrite();

            Console.ReadLine();
        }
    }
}
 Наследуемый класс в C#
Всякий раз, когда один класс наследует от другого, после имени производного класса указывается имя базового класса, отделяемое двоеточием. В C# синтаксис наследования класса удивительно прост и удобен в использовании. Ниже представлено схематичное представление класса CSharp из вышеуказанного примера:

Схематическое представление наследуемого класса в C#
Как видите класс CSharp получает доступ к полям и методам класса ProfessorWeb. Всегда помните, что наследование предохраняет инкапсуляцию, а потому приватные члены никогда не могут быть доступны через ссылку на объект. Т.е. поле inf из примера не может быть доступно для вызова с помощью экземпляра класса obj.

Для любого производного класса можно указать только один базовый класс. В C# не предусмотрено наследование нескольких базовых классов в одном производном классе. (В этом отношении C# отличается от С++, где допускается наследование нескольких базовых классов. Данное обстоятельство следует принимать во внимание при переносе кода С++ в C#.) Тем не менее можно создать иерархию наследования, в которой производный класс становится базовым для другого производного класса. (Разумеется, ни один из классов не может быть базовым для самого себя как непосредственно, так и косвенно.) Но в любом случае производный класс наследует все члены своего базового класса, в том числе переменные экземпляра, методы, свойства и индексаторы.

Главное преимущество наследования заключается в следующем: как только будет создан базовый класс, в котором определены общие для множества объектов атрибуты, он может быть использован для создания любого числа более конкретных производных классов. А в каждом производном классе может быть точно выстроена своя собственная классификация.




3. Пусть базовый класс содержит метод basefunc(), а производный класс не имеет метода с таким именем. Может ли объект производного класса иметь доступ к методу basefunc()? Если да, то при каких условиях?
4. Напишите объявление конструктора без аргументов для производного класса B, который будет вызывать конструктор без аргументов базового класса A.
5. Что такое полиморфизм? Приведите пример.
6. Определите назначение виртуальных функций.
7. Кому доступны переменные с модификатором protected?
8. Наследуются ли переменные с модификатором private?
9. As, is – что это, как применяется?
10. Поддерживает ли C# множественное наследование?
11. Можно ли запретить наследование от класса?
12. Можно ли разрешить наследование класса, но запретить перекрытие
метода?
13. Что такое абстрактный класс?
14. В каком случае вы обязаны объявить класс абстрактным?
15. В чем разница между абстрактными и виртуальными классами? Между
виртуальными и абстрактными методами?
16. Какие компоненты класса могут быть виртуальными?
17. Что такое интерфейс?
18. Как работать с объектом через унаследованный интерфейс?
19. Приведите пример явной реализации интерфейса.
20. Почему нельзя указать модификатор видимости для методов интерфейса? 21. Можно ли наследовать от нескольких интерфейсов?
22. Назовите отличия между интерфейсом и абстрактным классом.
23. Для чего используются стандартные интерфейсы ICloneable, IComparable,
IComparer, lEnumerable?
24. В какой строке приведенного ниже фрагмента листинга не содержится
ошибки?
class A {
public virtual abstract void m() { } //1 public virtual void g() { }//2
public virtual new new void f() { }//3 public static virtual void h() { }//4
     }
   25.
 Что
будет
 выведено на консоль в результате выполнения следующего фрагмента?
      class A {
    public int x = 1;
}
class B : A {
    public new int x = 2;
    public void m(int a, int b)
    {
x = a;
base.x = b;
Console.Write(x + " " + base.x);
} }
class Test {
    static void Main(string[] args)
    {
                                    A a = new A();
B b = new B();
b.m(3, 4);
        } }
       26.
Что будет выведено на консоль в результате выполнения следующего фрагмента
кода?
     class A {
    public class B : A
    {
        public override void mA()
        {
            Console.WriteLine("B ");
        }
}
public virtual void mA()
          {
              Console.WriteLine("A ");
} }
class Prоgrаm
{
    static void Main(string[] args)
    {
        A a = new A();
        A.B b = new A.B();
        a.mA();
        b.mA();
} }
                                                    
                                                        27.
 Чем может быть M4 если дано следующее определение:
 Варианты ответа:
1) 2) 3) 4) 5)
1) 2) 3) 4) 5)
 M4 - только интерфейс
      public class C1 : M1, M2 { } public struct S1 : M3, M4 { };
 M4 - интерфейс или класс
   M4 - только класс
    M4 - только структура
 M4 - делегат
28.
 Выберите верное присваивание для объектов, определенных в листинге.
     class A { }
        class B : A { }
        class C : B { }
        class D { }
        class Test
        {
            static void Main(string[] args)
            {
                A a = new A();
                B b = new B();
                C c = new C();
                D d = new D();
} }
                                29.
Что будет выведено на консоль в результате выполнения следующего фрагмента,
public abstract class A
        {
если раскомментировать строчку 1?
    public virtual void method()
    { Console.Write("A "); }
}
public class B : A
{
Варианты ответа:
    public override void method()
    {  // base.method(); // 1
        // this.method();  // 2
        Console.Write("B ");
    }
}
1) B
2) A
3) 4)
5) 0
Варианты ответа:
 b = a; a = b;
 c = a;
 d = a; с = b;
   AB BA
 class Program2
{
    static void Main(string[] args)
{
    A my = new B();
    my.method();
} }
 
 30. В какой строке приведенного ниже фрагмента листинга содержится ошибка?
     public abstract class A
{
public virtual string m() { return "A"; }//1 }
public class B : A
{
    public override new string m() { return "B"; }//2
}
public class C : B
{
    public string m() { return "C"; }//3
}
class Prоgrаm
{
    static void Main(string[] args)
    {
        A ac = new C(); //4
        Console.WriteLine(ac.m());
} }
                                            31. Почему приведенный ниже фрагмент листинга содержит ошибку?
     abstract class Student //1
        {
            public int Age { get; set; } //2
public string Name { get; set; } //3 }
        static void Main(string[] args)
        {
            Student Olga = new Student();//4
        }
                        32. В какой строке может быть ошибка компиляции?
     class A{}
        class B : A { }
        class C : A { } //1
        class Program4
        {
            static void Main()
            {
} }
A one = new B(); //2 A two = new C(); //3 one = two; //4
  
 33. Что будет выведено на консоль в результате выполнения следующего фрагмента листинга:
interface Interface1
        {
void f();
void g(); }
class A {
public void f() { System.Console.WriteLine("F"); }
public void g() { System.Console.WriteLine("G"); } }
        class B : A, Interface1
        {
new public void g() { System.Console.WriteLine("new G");
}
}
        class Program5
        {
            static void Main(string[] args)
            {
} }
//Interface1 obj = new B();
//obj.g();
B obj = new B();
obj.g();
.
